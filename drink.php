<?php

//For full code and context: https://github.com/borpglass/neighborhood-data-parser

//Make the script not conk out as it guzzles pdfs
ini_set('memory_limit', '512M');
//Instantiate our pdfdrinker objet
$drinker = new pdfdrinker;
//Tell the pdfdrinker where to find its files
$files = $drinker->getfilelist(getcwd(),'.pdf.txt');
//Get a big recursive array of all our pdf data. Each file should be read from the start through the string "AGE 0"
$racearray = $drinker->makebigsoda($files,"","AGE 0");
//Do some custom stuff to get just the race stats we want. (See custom function below for detailed logic.)
$racearray = customclean($racearray,'race');
//Now do some more stuff to get age stats. 
$agearray = $drinker->makebigsoda($files,"","Family Household Type");
$agearray = customclean($agearray,'age');


$bigarray = joincleaned($racearray,$agearray);

print("\n\nYup.\n\n");
print_r($bigarray);


$csvpointer = fopen('output.csv','w');
fwrite($csvpointer,implode(',',array_keys($bigarray[0]))."\n");
foreach($bigarray as $fields){
	fputcsv($csvpointer,$fields);
}
fclose($csvpointer);





//This if a one-off function for a specific use case, unlike the reusable pdfdrinker functions.
//It returns a nicely formatted array of racial (and maybe eventually other demographic) info for each place/pdf. 
function customclean($input,$type){
	if($type == 'race'){
		$output = array();
		foreach($input as $k=>$v){
			$better = trim($v);
			if(strpos($better,'TOTAL POPULATION') !== false){
				$temporary[] = $better;
			}
		}
		foreach($temporary as $k=>$v){
			$bigchunks = explode('TOTAL POPULATION',$v);
			$firstchunkrows = explode("\n",$bigchunks[0]);
			$bigchunks[0] = trim($firstchunkrows[0]);
			//if($bigchunks[0] == 'Sandtown-Winchester' || $bigchunks[0] == 'Perkins Homes' || $bigchunks[0] == 'Morgan State University'){
			//print_r($bigchunks);
				$output[$k]['neighborhood-statistical-area'] = trim($bigchunks[0]);
				$asoneline = preg_replace('/\n/msi', ' ', $bigchunks[2]);
				preg_match_all('/[0-9,-.]+\s/',$asoneline,$racechunks);	
				$output[$k]['twenty-ten-overall-population'] = $racechunks[0][0];
				$output[$k]['twenty-ten-white-percentage'] = $racechunks[0][8];
				$output[$k]['twenty-ten-black-percentage'] = $racechunks[0][9];
				$output[$k]['twenty-ten-american-indian-percentage'] = $racechunks[0][10];
				$output[$k]['twenty-ten-asian-percentage'] = $racechunks[0][11];
				$output[$k]['twenty-ten-other-percentage'] = $racechunks[0][12];
				$output[$k]['twenty-ten-mixed-percentage'] = $racechunks[0][13];
				$output[$k]['twenty-ten-hispanic-percentage'] = $racechunks[0][14];
			//}
		}
	}elseif($type == 'age'){
		$output = array();
		foreach($input as $k=>$v){
			$better = trim($v);
			if(strpos($better,'4 Years 5') !== false){
				$temporary[] = $better;
			}
		}
//print_r($temporary);
		foreach($temporary as $k=>$v){
			$bigchunks = explode('Years 65+ Years',$v);
			$hoodname = explode('SUBJECT',$bigchunks[0]);
			$hoodname = str_replace('2000 Census','',$hoodname[0]);
			$hoodname = trim($hoodname);
			$asoneline = preg_replace('/\n/msi', ' ', $bigchunks[2]);
			preg_match_all('/[0-9,-.]+\s/',$asoneline,$agechunks);	
			$output[$k]['neighborhood-statistical-area'] = $hoodname;
			$output[$k]['twenty-ten-percent-age-0-to-4-years'] = $agechunks[0][1];
			$output[$k]['twenty-ten-percent-age-5-to-11-years'] = $agechunks[0][5];
			$output[$k]['twenty-ten-percent-age-12-to-14-years'] = $agechunks[0][9];
			$output[$k]['twenty-ten-percent-age-15-to-17-years'] = $agechunks[0][13];
			$output[$k]['twenty-ten-percent-age-18-to-24-years'] = $agechunks[0][17];
			$output[$k]['twenty-ten-percent-age-25-to-34-years'] = $agechunks[0][21];
			$output[$k]['twenty-ten-percent-age-35-to-44-years'] = $agechunks[0][25];
			$output[$k]['twenty-ten-percent-age-45-to-64-years'] = $agechunks[0][29];
			$output[$k]['twenty-ten-percent-age-65-and-up-years'] = $agechunks[0][33];

		}
	}
	return($output);
}



//This is a one-off function for merging the two arrays generated by the customclean function.
function joincleaned($arrayone,$arraytwo){
	foreach($arrayone as $k1=>$v1){
		$output[$k1] = $v1;
		foreach($arraytwo[$k1] as $k2=>$v2){
			$output[$k1][$k2] = $v2;
		}
	}
	return($output);
}







//Tried to make most of this at least a bit reusable for other situations.
//So it includes a tweakable function for grabbing all local .pdf.txt files, and one for putting a predefined slice of 
//each file into an array.
//Logic partially borrowed/modded from 
//https://github.com/borpglass/simple-sequential-scraper-tools/blob/master/smashbigtables.php

class pdfdrinker{ 
	//This class assumes you ahve already run pdftotext on a bunch of files.
	//These tasks allow you to clean up the output into a format that is useful -- usually csv.
	public function getfilelist($dir='', $extension = '.pdf.txt'){
			//This function returns a list of files, the better for us to do things with them. 
			$this->extension = $extension;
			$this->skipfirstrow = true;
			$dir = $dir != '' ? $dir : getcwd();
			$allfiles = scandir($dir);
			$ourfiles = array();
			foreach($allfiles as $index => $filename){
				if(strpos($filename,$extension) !== false){
					$ourfiles[] = $filename;
				}else{
					//print("\nDiscarding file $filename");
				}
			}
			$existingrows = array();
			return($ourfiles);
	}
	public function makebigsoda($files,$startstring="",$endstring=""){
	//This function will concatenate a bunch of pieces of our converted pdfs into an array of more manageable items. 
	//The first instance of $startstring will denote the beginning of what we want from each file.
	//The first instance of $endstring will denote the end of what we want in each file.
		$output = array();
		foreach($files as $k => $v){
			$contents = file_get_contents($v);
			if($startstring != ""){
				$clipped = explode($startstring,$contents);
				$clipped = array_pop($clipped);
			}else{
				$clipped = $contents;
			}
			if($endstring != ""){
				$clipped = explode($endstring,$clipped);
				$clipped = array_shift($clipped);
			}else{
				$clipped = $clipped;
			}
			$output[] = $clipped;
		}
		return($output);
	}
}


?>
